import fs from 'fs/promises';

import { CodeGen } from '../lib/combo/util/codegen';
import { decompressGame } from '../lib/combo/decompress';
import { CONFIG } from '../lib/combo/config';
import { mkdir } from 'fs';

type Game = 'oot' | 'mq';

const ACTORS_OOT = {
  POT: 0x111,
  FLYING_POT: 0x11d,
  ROCK_BUSH_GROUP: 0x151,
  EN_KUSA: 0x125,
  OBJ_HANA: 0x14f,
};

const CONFIGS = {
  oot: {
    SCENE_TABLE_ADDR: 0xb71440,
    SCENE_TABLE_SIZE: 101,
  },
  mq: {
    SCENE_TABLE_ADDR: 0xba0bb0,
    SCENE_TABLE_SIZE: 101,
  },
}

type RawRoom = {
  sceneId: number;
  roomId: number;
  setupId: number;
  vromBase: number;
  vromHeader: number;
}

type Actor = {
  offset: number;
  actorId: number;
  typeId: number;
  rz: number;
  params: number;
}

type Room = {
  sceneId: number;
  roomId: number;
  setupId: number;
  vromBase: number;
  actors: Actor[];
  objects: number[];
}

const ACTOR_OBJECTS: { [key: number]: number | number[] } = {
  //0x0000: [0x0014, 0x0015], /* ??? */
  0x0002: 0x0032,
  0x0004: 0x0001,
  0x0007: 0x0001,
  0x0008: 0x0001,
  0x0009: 0x0001,
  0x000A: 0x000E,
  0x000B: 0x000A,
  0x000C: 0x002C,
  //0x000D: 0x0009, ????,
  0x000E: 0x0007,
  0x000F: 0x0036,
  0x0010: 0x0001,
  0x0011: 0x000B,
  0x0012: 0x000C,
  0x0013: 0x000D,
  0x0014: 0x001A,
  0x0015: 0x0001,
  0x0016: 0x0001,
  0x0018: 0x0001,
  0x0019: 0x0013,
  0x001B: 0x0016,
  0x001C: 0x0017,
  0x001D: 0x0018,
  0x001E: 0x0002,
  0x0020: 0x0001,
  0x0021: 0x0001,
  0x0023: 0x0001,
  0x0024: 0x0040,
  0x0025: 0x001B,
  0x0026: 0x0076,
  0x0027: 0x0019,
  0x0028: 0x001C,
  0x0029: 0x001D,
  0x002A: 0x0001,
  0x002B: 0x001E,
  0x002C: 0x0003,
  0x002D: 0x0012,
  0x002E: 0x0001,
  0x002F: 0x001F,
  0x0032: 0x0001,
  0x0033: 0x0020,
  0x0034: 0x0021,
  0x0035: 0x0022,
  0x0037: 0x0024,
  0x0038: 0x0025,
  0x0039: 0x0001,
  0x003A: 0x0026,
  0x003B: 0x0001,
  0x003C: 0x0027,
  0x003D: 0x0001, /*????,*/
  0x003E: 0x002A,
  0x003F: 0x002B,
  0x0040: 0x002C,
  0x0041: 0x002C,
  0x0042: 0x002D,
  0x0043: 0x002C,
  0x0044: 0x002C,
  0x0045: 0x002C,
  0x0046: 0x002C,
  0x0047: 0x002C,
  0x0048: 0x008A,
  0x0049: 0x0001,
  0x004A: 0x002F,
  0x004B: 0x0030,
  0x004C: 0x0031,
  0x004D: 0x0060,
  0x004E: 0x002C,
  0x004F: 0x0035,
  0x0050: 0x0036,
  0x0051: 0x0036,
  0x0052: 0x0037,
  0x0054: 0x0038,
  0x0055: 0x0039,
  0x0056: 0x0001,
  0x0057: 0x0001,
  0x0058: 0x002B,
  0x005A: 0x0040,
  0x005B: 0x0046,
  0x005C: 0x002B,
  0x005D: 0x0048,
  0x005E: 0x00A4,
  0x005F: 0x00BD,
  0x0060: 0x004A,
  0x0061: 0x004D,
  0x0062: 0x004D,
  0x0063: 0x0056,
  0x0064: 0x0059,
  0x0065: 0x0059,
  0x0066: 0x0014,
  0x0067: 0x005A,
  0x0069: 0x005D,
  0x006A: 0x005E,
  0x006B: 0x005F,
  0x006C: 0x005E,
  0x006E: [0x0001, 0x0061], /* ??? */
  0x006F: 0x002C,
  0x0070: 0x005E,
  0x0071: 0x002C,
  0x0072: 0x0077,
  0x0077: 0x007C,
  0x007C: 0x0081,
  0x007D: 0x0082,
  0x0080: 0x0085,
  0x0081: 0x0001,
  0x0082: 0x0086,
  0x0084: 0x0088,
  0x0085: 0x0089,
  0x0086: [0x0072, 0x0073],
  0x0087: [0x0072, 0x0073],
  0x0088: [0x0072, 0x0073],
  0x0089: [0x0072, 0x0073],
  0x008A: 0x008B,
  //0x008B: 0x????,
  0x008C: 0x0001, /*0x005E, ????,*/
  0x008D: 0x002C,
  0x008E: 0x000B,
  0x008F: 0x0097,
  0x0090: 0x0098,
  0x0091: 0x0099,
  0x0092: 0x009A,
  0x0093: 0x0099,
  0x0094: 0x0001,
  0x0095: 0x0024,
  0x0096: 0x009C,
  0x0097: [0x0001, /*????*/],
  0x0098: 0x009D,
  0x0099: 0x009E,
  0x009A: 0x00A0,
  0x009B: 0x0002,
  0x009C: 0x00A1,
  0x009D: 0x00A2,
  0x009E: 0x0001,
  0x009F: 0x0001,
  0x00A1: 0x00A3,
  0x00A2: 0x00A5,
  0x00A3: 0x0003,
  0x00A4: 0x00A6,
  0x00A5: 0x00A6,
  0x00A6: 0x00A7,
  //0x00A7: 0x0001, ????,
  0x00A8: 0x009D,
  0x00A9: 0x0087,
  0x00AA: 0x000E,
  0x00AB: 0x009E,
  0x00AC: 0x009C,
  0x00AD: 0x009C,
  0x00AE: 0x0001,
  0x00AF: 0x0069,
  0x00B0: 0x0069,
  0x00B1: [0x0001, /*????*/],
  0x00B3: 0x0097,
  0x00B4: 0x0092,
  0x00B5: 0x0092,
  0x00B6: 0x00AC,
  0x00B7: 0x00AB,
  0x00B8: 0x00AE,
  0x00B9: 0x00AF,
  0x00BA: 0x008C,
  0x00BB: 0x0069,
  0x00BC: 0x0069,
  0x00BD: 0x008D,
  0x00BE: 0x0001,//0x0069,
  0x00BF: 0x00B1,
  0x00C0: 0x0001,
  0x00C1: 0x005B,
  0x00C2: 0x00B2,
  0x00C3: 0x00B3,
  0x00C4: 0x00B4,
  0x00C5: 0x00B5,
  0x00C6: 0x015F,
  0x00C7: 0x0039,
  0x00C8: 0x0096,
  0x00C9: 0x00BC,
  0x00CA: 0x00C9,
  0x00CB: 0x00C0,
  0x00CC: 0x00C1,
  0x00CD: 0x00C2,
  0x00CF: 0x002C,
  0x00D0: 0x0002,
  0x00D1: 0x0074,
  0x00D2: 0x00CA,
  0x00D3: 0x00CC,
  0x00D4: 0x0059,
  0x00D5: 0x006A,
  0x00D6: 0x006B,
  0x00D7: 0x008D,
  0x00D9: 0x00D0,
  0x00DA: 0x0001,
  0x00DB: 0x0001,
  0x00DC: 0x00D3,
  0x00DD: 0x00D4,
  0x00DE: 0x00D5,
  0x00DF: 0x00D5,
  0x00E0: 0x00D6,
  0x00E1: 0x00D6,
  0x00E2: [0x0072, 0x0073],
  0x00E3: [0x0072, 0x0073],
  0x00E4: 0x0072,
  0x00E5: 0x017A,
  0x00E6: 0x0096,
  0x00E7: 0x00E0,
  0x00E8: [], //0x00E1, 017C, 017D,
  0x00E9: 0x00E2,
  0x00EC: 0x00E5,
  0x00ED: 0x00E6,
  0x00EE: 0x0015,
  0x00EF: 0x006B,
  0x00F0: 0x0001,
  0x00F1: 0x00DE,
  0x00F4: 0x0001,
  0x00F5: 0x0001,
  0x00F6: 0x0001,
  0x00F7: 0x0069,
  0x00F8: 0x00F0,
  0x00F9: 0x011F,
  0x00FA: 0x00F1,
  0x00FC: 0x00F1,
  0x00FD: 0x00F1,
  0x00FE: 0x015B,
  0x00FF: 0x0003,
  0x0100: 0x0181,
  0x0101: 0x0001,
  0x0102: 0x00F9,
  0x0103: 0x00F9,
  0x0104: 0x00F9,
  0x0105: 0x00A4,
  0x0106: 0x00E1,
  0x0107: 0x00F0,
  0x0108: 0x0100,
  0x010A: 0x0001,
  0x010B: 0x0001,
  0x010C: 0x0001,
  //0x010F: 0x0001, ????,
  0x0110: 0x0003,
  0x0111: 0x0001,
  0x0112: 0x0001,
  0x0113: 0x0106,
  0x0114: 0x0106,
  0x0115: 0x010A,
  0x0116: 0x010A,
  0x0117: 0x0001,
  0x0118: 0x005A,
  0x0119: 0x0001,
  0x011A: 0x0168,
  0x011B: 0x0001,
  0x011C: 0x0003,
  0x011D: 0x0003,
  0x011E: 0x0001,
  0x011F: 0x0112,
  0x0120: 0x0113,
  0x0121: 0x0114,
  0x0122: 0x0089,
  0x0123: 0x006C,
  0x0124: 0x00FE,
  //0x0125: 0x0001, ????,
  0x0126: 0x011E,
  0x0127: 0x0163,
  0x012A: 0x0003,
  0x012B: 0x011B,
  0x012C: 0x011D,
  0x012D: 0x011C,
  0x012E: 0x0001,
  0x012F: 0x0001,
  0x0130: 0x011F,
  0x0131: 0x0001,
  0x0132: 0x0121,
  0x0133: 0x0122,
  0x0135: 0x0124,
  0x0136: 0x0125,
  0x0137: 0x0001,
  0x0138: 0x0116,
  0x0139: 0x0001,
  0x013A: 0x0001,
  0x013B: 0x0001,
  0x013C: 0x0110,
  0x013D: 0x00C9,
  0x013E: 0x0127,
  0x013F: 0x0128,
  0x0140: 0x0129,
  0x0141: 0x012F,
  0x0142: 0x0097,
  0x0143: 0x0013,
  0x0144: 0x0013,
  0x0145: 0x0180,
  0x0146: 0x00BC,
  0x0147: 0x0001, /*????,*/
  0x0148: 0x0130,
  0x0149: 0x010F,
  0x014A: 0x0132,
  0x014B: 0x0160,
  0x014C: 0x0001,
  0x014D: 0x0131,
  0x014E: 0x0002,
  0x014F: 0x0002,
  0x0150: 0x012A,
  0x0151: 0x0001,
  0x0152: 0x00C9,
  0x0153: 0x0133,
  0x0155: 0x0001,
  0x0156: 0x00F1,
  0x0157: 0x00F1,
  0x0158: 0x00F1,
  0x0159: 0x00F1,
  0x015A: 0x00F1,
  0x015B: 0x00F1,
  0x015C: 0x00AF,
  0x015E: 0x00E1,
  0x015F: 0x013A,
  0x0160: 0x013B,
  0x0162: 0x013C,
  0x0163: 0x00C5,
  0x0164: 0x00FF,
  0x0165: 0x0001,
  0x0166: 0x00E2,
  0x0167: 0x00EC,
  0x0168: 0x0001,
  0x0169: 0x016C,
  0x016A: 0x0144,
  0x016B: 0x0001,
  0x016C: 0x0145,
  0x016D: 0x00FB,
  0x016E: 0x0001, /*[00C5, ????,*/
  0x016F: 0x0001,
  0x0170: 0x0001,
  0x0171: 0x014A,
  0x0172: 0x014B,
  0x0173: 0x0001,
  0x0174: /*0x014C,*/ 0x0001,
  0x0175: 0x006D,
  0x0176: 0x014D,
  0x0177: 0x0156,
  0x0178: 0x0097,
  0x0179: 0x0060,
  0x017A: 0x0153,
  0x017B: 0x0154,
  0x017C: 0x0155,
  0x017D: 0x0003,
  0x017E: 0x0001,
  0x017F: 0x0001,
  0x0181: 0x0001,
  //0x0182: 0x015A, ????,
  0x0183: 0x0001,
  0x0184: 0x000A,
  0x0185: 0x0001,
  0x0186: 0x0167,
  0x0187: 0x0001,
  0x0188: 0x015E,
  0x0189: 0x0001,
  0x018A: 0x0001,
  0x018B: 0x0001,
  0x018C: 0x0026,
  0x018D: 0x0161,
  0x018E: 0x00F1,
  0x018F: 0x016C,
  0x0190: 0x0162,
  0x0191: 0x0162,
  0x0192: 0x0164,
  0x0193: 0x0001,
  0x0194: 0x0166,
  0x0195: 0x0168,
  0x0196: 0x0001,
  0x0197: 0x0169,
  0x0198: 0x0001,
  0x0199: 0x0001,
  0x019A: 0x016A,
  0x019B: 0x016B,
  0x019C: 0x0024,
  0x019D: 0x0001,
  0x019E: 0x0002,
  0x019F: 0x016F,
  0x01A0: 0x0170,
  0x01A1: 0x0001,
  0x01A2: 0x0171,
  0x01A3: 0x0001,
  0x01A4: 0x0111,
  0x01A5: 0x0178,
  0x01A6: 0x0128,
  0x01A7: 0x0179,
  0x01A8: 0x0074,
  0x01A9: 0x00B1,
  0x01AB: 0x0001,
  0x01AC: 0x0182,
  0x01AD: 0x0182,
  0x01AE: 0x00C9,
  0x01AF: 0x0183,
  0x01B0: 0x0184,
  0x01B1: 0x0185,
  0x01B2: 0x0186,
  0x01B3: 0x0179,
  0x01B4: 0x0179,
  0x01B5: 0x0179,
  0x01B6: 0x0179,
  0x01B7: 0x0179,
  0x01B8: 0x0189,
  0x01B9: 0x0188,
  0x01BA: 0x0059,
  0x01BB: 0x0059,
  0x01BC: 0x0122,
  0x01BD: 0x0178,
  0x01BE: 0x0001,
  0x01BF: 0x006D,
  0x01C0: 0x0008,
  0x01C1: 0x018E,
  0x01C2: 0x016F,
  0x01C3: 0x00AF,
  0x01C4: 0x00AF,
  0x01C5: 0x00D0,
  0x01C6: 0x018B,
  0x01C7: 0x006B,
  0x01C8: 0x006B,
  0x01C9: 0x0154,
  0x01CA: 0x0154,
  0x01CB: 0x0001,
  0x01CC: 0x0060,
  0x01CD: 0x004D,
  0x01CE: 0x00FE,
  0x01CF: 0x0001,
  0x01D0: 0x0169,
  0x01D1: [0x0190, 0x00A8],
  0x01D2: 0x0002,
  0x01D3: 0x0191,
  0x01D4: 0x013C,
  0x01D5: 0x0003,
  0x01D6: 0x0190,
};

function sceneObjects(sceneId: number): number[] {
  let objects: number[] = [0x0001];
  let isDungeon = false;

  if (sceneId < 0x1b) {
    isDungeon = true;
  }

  if (sceneId === 0x48) {
    isDungeon = true;
  }

  if (!isDungeon) {
    objects.push(0x0002);
  } else {
    objects.push(0x0003);
  }

  return objects;
}

function actorObjects(actor: Actor): number[] {
  const id = actor.typeId;
  const objects = ACTOR_OBJECTS[id];

  /* Bg_Breakwall */
  if (id === 0x59) {
    const v = (actor.params >>> 0xd) & 3;
    return v < 2 ? [0x18a] : [0x19];
  }

  /* Demo_Effect, ignored */
  if (id === 0x8b) {
    return [];
  }

  /* Poe */
  if (id === 0x0d) {
    if ([2, 3].includes(actor.params))
      return [0x006e];
    return [0x0009];
  }

  /* Twisted hall */
  if (id === 0x68) {
    return [];
  }

  /* Enemy spawner */
  if (id === 0xa7) {
    const v = (actor.params >>> 0xb) & 0x1f;
    switch (v) {
    case 0: return [0x0017];
    case 1: return [0x0016];
    case 2: return [0x0184];
    case 3: return [0x0183];
    }
  }

  /* Item_Etcetera */
  if (id === 0x10f) {
    switch (actor.params) {
    case 0: return [0x00c6];
    case 1: return [0x010b];
    case 2: return [0x00dc];
    case 3: return [0x00be];
    case 4: return [0x00db];
    case 5: return [0x00db];
    case 6: return [0x00aa];
    case 7: return [0x0158];
    }
  }

  /* Obj_Tsubo */
  if (id === 0x111) {
    if (actor.params & 0x0100) {
      /* Use tsubo object file */
      return [0x012c];
    } else {
      /* Use dangeon keep */
      return [0x0003];
    }
  }

  if (id === 0x125) {
    const v = (actor.params & 3);
    if (v === 0) {
      return [0x0002];
    } else {
      return [0x012b];
    }
  }
  if (objects === undefined) {
    throw new Error(`Unknown actor object for 0x${id.toString(16)}`);
  }
  if (typeof objects === 'number') {
    return [objects];
  }
  return objects;
}

function canActorLoad(actor: Actor, room: Room): boolean {
  const ao = actorObjects(actor);
  const so = sceneObjects(room.sceneId);
  const objects = [...so, ...room.objects];
  if (ao.some(x => !objects.includes(x))) {
    return false;
  }
  return true;
}

function checkRooms(rooms: Room[]) {
  for (const r of rooms) {
    for (let ai = 0; ai < r.actors.length; ++ai) {
      const a = r.actors[ai];
      if (!canActorLoad(a, r)) {
        console.log(`{ 0x${r.sceneId.toString(16)}, 0x${r.roomId.toString(16)}, 0x${ai.toString(16)} },`);
        //console.log(`Actor 0x${a.typeId.toString(16)} cannot load in room ${r.sceneId.toString(16)}-${r.roomId.toString(16)}-${r.setupId} (Addr: 0x${r.vromBase.toString(16)} + 0x${a.offset.toString(16)})`);
      }
    }
  }
}

function findHeaderOffset(rom: Buffer, offset: number, wantedOp: number) {
  for (;;) {
    const op = rom.readUInt8(offset);
    if (op === wantedOp) {
      return offset;
    }
    if (op === 0x14) {
      return null;
    }
    offset += 8;
  }
}

function parseRoom(rom: Buffer, raw: RawRoom, game: Game): Room[] {
  const typeIdMask = 0xffff;
  const actors: Actor[] = [];

  const actorHeaders = findHeaderOffset(rom, raw.vromHeader, 0x01);
  if (actorHeaders !== null) {
    const actorCount = (rom.readUInt32BE(actorHeaders) >> 16) & 0xff;
    const actorVromDelta = (rom.readUInt32BE(actorHeaders + 4) & 0xffffff);
    const actorsVrom = raw.vromBase + actorVromDelta;
    for (let actorId = 0; actorId < actorCount; actorId++) {
      const actorVromBase = actorsVrom +  0x10 * actorId;
      const typeId = rom.readUInt16BE(actorVromBase + 0x00) & typeIdMask;
      const rz = rom.readUInt16BE(actorVromBase + 0x0c);
      const params = rom.readUInt16BE(actorVromBase + 0x0e);
      actors.push({ actorId, typeId, rz, params, offset: actorVromDelta + 0x10 * actorId });
    }
  }

  const objectsHeaders = findHeaderOffset(rom, raw.vromHeader, 0x0b);
  let objects: number[] = [];
  if (objectsHeaders !== null) {
    const objectCount = (rom.readUInt32BE(objectsHeaders) >> 16) & 0xff;
    const objectsVrom = raw.vromBase + (rom.readUInt32BE(objectsHeaders + 4) & 0xffffff);
    for (let objectIndex = 0; objectIndex < objectCount; objectIndex++) {
      const objectVromBase = 0x02 * objectIndex + objectsVrom;
      const objectId = rom.readUInt16BE(objectVromBase + 0x00);
      objects.push(objectId);
    }
  }

  return [{ sceneId: raw.sceneId, setupId: raw.setupId, roomId: raw.roomId, actors, objects, vromBase: raw.vromBase }];
}

function getRawRooms(rom: Buffer, game: Game) {
  const rooms: RawRoom[] = [];
  const config = CONFIGS[game];
  for (let sceneId = 0; sceneId < config.SCENE_TABLE_SIZE; sceneId++) {
    const sceneVrom = rom.readUInt32BE(config.SCENE_TABLE_ADDR + sceneId * 0x14);
    if (sceneVrom === 0)
      continue;
    const roomsHeaderVrom = findHeaderOffset(rom, sceneVrom, 0x04);
    if (roomsHeaderVrom === null)
      continue;
    const roomsCount = (rom.readUInt32BE(roomsHeaderVrom) >> 16) & 0xff;
    const roomsVrom = sceneVrom + (rom.readUInt32BE(roomsHeaderVrom + 4) & 0xffffff);
    for (let roomId = 0; roomId < roomsCount; roomId++) {
      const roomFileVrom = rom.readUint32BE(roomsVrom + roomId * 8);

      /* Push the default setup */
      rooms.push({ sceneId, setupId: 0, roomId, vromBase: roomFileVrom, vromHeader: roomFileVrom });

    /* Look for alternate setups */
      const altHeaderOffset = findHeaderOffset(rom, roomFileVrom, 0x18);
      if (altHeaderOffset === null)
        continue;
      const altHeaderListVrom = roomFileVrom + (rom.readUInt32BE(altHeaderOffset + 4) & 0xffffff);
      for (let setupId = 1; setupId < 4; ++setupId) {
        const setupAddr = rom.readUInt32BE(altHeaderListVrom + (setupId - 1) * 4);
        if (setupAddr === 0)
          continue;
        const setupVrom = roomFileVrom + (setupAddr & 0xffffff);
        rooms.push({ sceneId, setupId, roomId, vromBase: roomFileVrom, vromHeader: setupVrom });
      }
    }
  }
  return rooms;
}

function hexPad(n: number, width: number) {
  const s = n.toString(16);
  return '0x' + '0'.repeat(width - s.length) + s;
}

function decPad(n: number, width: number) {
  const s = n.toString();
  const count = width - s.length;
  return count > 0 ? '0'.repeat(width - s.length) + s : s;
}

function roomActorsFromRaw(rom: Buffer, raw: RawRoom[], game: Game): Room[] {
  const actorsRooms = raw.map(r => parseRoom(rom, r, game)).flat();
  return actorsRooms;
}

function getGameRoomActor(rom: Buffer, game: Game) {
  const rawRooms = getRawRooms(rom, game);
  const actorRooms = roomActorsFromRaw(rom, rawRooms, game);
  return actorRooms;
}

async function run() {
  /* Get OoT ROM */
  const ootRomCompressed = await fs.readFile(__dirname + '/../../../roms/oot.z64');
  const ootDecompressed = await decompressGame('oot', ootRomCompressed);
  const ootRom = ootDecompressed.rom;

  /* Get MQ ROM */
  const mqRom = await fs.readFile(__dirname + '/../../../roms/mq.z64');

  /* Get OoT Rooms */
  const ootRooms = getGameRoomActor(ootRom, 'oot');

  /* Get MQ Rooms */
  const mqRooms = getGameRoomActor(mqRom, 'mq');

  //console.log(ootRooms);

  checkRooms(mqRooms);
}

run().catch(e => {
  console.error(e);
  process.exit(1);
});
